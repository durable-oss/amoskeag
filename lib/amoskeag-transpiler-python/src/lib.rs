//! Amoskeag to Python Transpiler
//!
//! This crate provides functionality to transpile Amoskeag programs to Python code.
//! The generated Python code maintains the functional and safe properties of Amoskeag
//! while being executable in a standard Python environment.

use amoskeag_parser::{BinaryOp, Expr, UnaryOp};
use std::fmt::Write;
use thiserror::Error;

/// Errors that can occur during transpilation
#[derive(Error, Debug)]
pub enum TranspileError {
    #[error("Failed to format Python code: {0}")]
    FormatError(String),

    #[error("Unsupported expression: {0}")]
    UnsupportedExpression(String),
}

/// Configuration for the transpiler
#[derive(Debug, Clone)]
pub struct TranspileConfig {
    /// Indentation string (default: 4 spaces)
    pub indent: String,
    /// Whether to include runtime imports
    pub include_runtime_imports: bool,
    /// Whether to generate type hints
    pub type_hints: bool,
}

impl Default for TranspileConfig {
    fn default() -> Self {
        Self {
            indent: "    ".to_string(),
            include_runtime_imports: true,
            type_hints: true,
        }
    }
}

/// Transpile an Amoskeag AST to Python code
///
/// # Arguments
///
/// * `expr` - The AST expression to transpile
/// * `config` - Configuration for the transpiler
///
/// # Returns
///
/// A string containing the generated Python code
pub fn transpile(expr: &Expr, config: &TranspileConfig) -> Result<String, TranspileError> {
    let mut output = String::new();

    // Add runtime imports if configured
    if config.include_runtime_imports {
        writeln!(
            &mut output,
            "# Generated by Amoskeag Python Transpiler\nfrom typing import Any, Dict, List, Optional, Union\nimport math\n"
        )
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    }

    // Generate the main function
    writeln!(&mut output, "def evaluate(data: Dict[str, Any]) -> Any:")
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        &mut output,
        "{}\"\"\"Evaluate the Amoskeag program.\"\"\"",
        config.indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;

    // Generate helper functions
    generate_helpers(&mut output, &config.indent)?;

    // Generate the main expression
    writeln!(
        &mut output,
        "{}return {}",
        config.indent,
        transpile_expr(expr, &config.indent, 1)?
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;

    Ok(output)
}

/// Generate helper functions for the Python runtime
fn generate_helpers(output: &mut String, indent: &str) -> Result<(), TranspileError> {
    // Helper for safe dictionary access
    writeln!(
        output,
        "{}def _get_nested(obj: Any, *keys: str) -> Any:",
        indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        output,
        "{}{}\"\"\"Safely navigate nested dictionaries.\"\"\"",
        indent, indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}current = obj", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}for key in keys:", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        output,
        "{}{}{}if isinstance(current, dict):",
        indent, indent, indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        output,
        "{}{}{}{}current = current.get(key)",
        indent, indent, indent, indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}{}else:", indent, indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        output,
        "{}{}{}{}return None",
        indent, indent, indent, indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}{}if current is None:", indent, indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        output,
        "{}{}{}{}return None",
        indent, indent, indent, indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}return current", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output).map_err(|e| TranspileError::FormatError(e.to_string()))?;

    // Helper for truthiness
    writeln!(output, "{}def _is_truthy(val: Any) -> bool:", indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        output,
        "{}{}\"\"\"Check if a value is truthy in Amoskeag.\"\"\"",
        indent, indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}if val is None:", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}{}return False", indent, indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}if isinstance(val, bool):", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}{}return val", indent, indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}return True", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output).map_err(|e| TranspileError::FormatError(e.to_string()))?;

    Ok(())
}

/// Transpile an expression to Python code
#[allow(clippy::only_used_in_recursion)]
fn transpile_expr(expr: &Expr, indent: &str, depth: usize) -> Result<String, TranspileError> {
    match expr {
        // Literals
        Expr::Number(n) => Ok(format!("{}", n)),
        Expr::String(s) => Ok(format!("{:?}", s)),
        Expr::Boolean(b) => Ok(if *b { "True" } else { "False" }.to_string()),
        Expr::Nil => Ok("None".to_string()),
        Expr::Symbol(s) => Ok(format!("\":{}\"", s)),

        // Array literal
        Expr::Array(elements) => {
            let mut parts = Vec::new();
            for elem in elements {
                parts.push(transpile_expr(elem, indent, depth)?);
            }
            Ok(format!("[{}]", parts.join(", ")))
        }

        // Dictionary literal
        Expr::Dictionary(pairs) => {
            let mut parts = Vec::new();
            for (key, value) in pairs {
                let value_code = transpile_expr(value, indent, depth)?;
                parts.push(format!("{:?}: {}", key, value_code));
            }
            Ok(format!("{{{}}}", parts.join(", ")))
        }

        // Variable access (with dot navigation)
        Expr::Variable(path) => {
            if path.is_empty() {
                return Ok("None".to_string());
            }

            if path.len() == 1 {
                // Simple variable - check data dict first
                Ok(format!("data.get({:?})", path[0]))
            } else {
                // Nested access using helper
                let keys = path
                    .iter()
                    .map(|k| format!("{:?}", k))
                    .collect::<Vec<_>>()
                    .join(", ");
                Ok(format!("_get_nested(data, {})", keys))
            }
        }

        // Function call
        Expr::FunctionCall { name, args } => {
            let arg_codes: Result<Vec<_>, _> = args
                .iter()
                .map(|a| transpile_expr(a, indent, depth))
                .collect();
            let arg_codes = arg_codes?;

            // Map Amoskeag functions to Python equivalents
            match name.as_str() {
                // String functions
                "upcase" => Ok(format!("{}.upper()", arg_codes[0])),
                "downcase" => Ok(format!("{}.lower()", arg_codes[0])),
                "capitalize" => Ok(format!("{}.capitalize()", arg_codes[0])),
                "strip" => Ok(format!("{}.strip()", arg_codes[0])),
                "split" => Ok(format!("{}.split({})", arg_codes[0], arg_codes[1])),
                "join" => Ok(format!("{}.join({})", arg_codes[1], arg_codes[0])),
                "truncate" => Ok(format!("{}[:int({})]", arg_codes[0], arg_codes[1])),
                "replace" => Ok(format!(
                    "{}.replace({}, {})",
                    arg_codes[0], arg_codes[1], arg_codes[2]
                )),

                // Numeric functions
                "abs" => Ok(format!("abs({})", arg_codes[0])),
                "ceil" => Ok(format!("math.ceil({})", arg_codes[0])),
                "floor" => Ok(format!("math.floor({})", arg_codes[0])),
                "round" => {
                    if arg_codes.len() == 2 {
                        Ok(format!("round({}, int({}))", arg_codes[0], arg_codes[1]))
                    } else {
                        Ok(format!("round({})", arg_codes[0]))
                    }
                }
                "plus" => Ok(format!("({} + {})", arg_codes[0], arg_codes[1])),
                "minus" => Ok(format!("({} - {})", arg_codes[0], arg_codes[1])),
                "times" => Ok(format!("({} * {})", arg_codes[0], arg_codes[1])),
                "divided_by" => Ok(format!("({} / {})", arg_codes[0], arg_codes[1])),
                "modulo" => Ok(format!("({} % {})", arg_codes[0], arg_codes[1])),
                "max" => Ok(format!("max({}, {})", arg_codes[0], arg_codes[1])),
                "min" => Ok(format!("min({}, {})", arg_codes[0], arg_codes[1])),

                // Collection functions
                "size" => Ok(format!(
                    "len({} if {} is not None else [])",
                    arg_codes[0], arg_codes[0]
                )),
                "first" => Ok(format!(
                    "({}[0] if {} and len({}) > 0 else None)",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "last" => Ok(format!(
                    "({}[-1] if {} and len({}) > 0 else None)",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "contains" => Ok(format!("({} in {})", arg_codes[1], arg_codes[0])),
                "sum" => Ok(format!(
                    "sum({} if {} is not None else [])",
                    arg_codes[0], arg_codes[0]
                )),
                "avg" => Ok(format!(
                    "(sum({}) / len({}) if {} and len({}) > 0 else None)",
                    arg_codes[0], arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "sort" => Ok(format!(
                    "sorted({} if {} is not None else [])",
                    arg_codes[0], arg_codes[0]
                )),
                "keys" => Ok(format!(
                    "list({}.keys() if {} is not None else [])",
                    arg_codes[0], arg_codes[0]
                )),
                "values" => Ok(format!(
                    "list({}.values() if {} is not None else [])",
                    arg_codes[0], arg_codes[0]
                )),
                "reverse" => Ok(format!(
                    "list(reversed({} if {} is not None else []))",
                    arg_codes[0], arg_codes[0]
                )),
                "at" => Ok(format!(
                    "({}[int({})] if {} and int({}) < len({}) else None)",
                    arg_codes[0], arg_codes[1], arg_codes[0], arg_codes[1], arg_codes[0]
                )),

                // Logic functions
                "choose" => Ok(format!(
                    "({}[int({}) - 1] if {} and int({}) > 0 and int({}) <= len({}) else None)",
                    arg_codes[1],
                    arg_codes[0],
                    arg_codes[1],
                    arg_codes[0],
                    arg_codes[0],
                    arg_codes[1]
                )),
                "if_then_else" => Ok(format!(
                    "({} if _is_truthy({}) else {})",
                    arg_codes[1], arg_codes[0], arg_codes[2]
                )),
                "is_number" => Ok(format!("isinstance({}, (int, float))", arg_codes[0])),
                "is_string" => Ok(format!("isinstance({}, str)", arg_codes[0])),
                "is_boolean" => Ok(format!("isinstance({}, bool)", arg_codes[0])),
                "is_nil" => Ok(format!("({} is None)", arg_codes[0])),
                "is_array" => Ok(format!("isinstance({}, list)", arg_codes[0])),
                "is_dictionary" => Ok(format!("isinstance({}, dict)", arg_codes[0])),
                "coalesce" => Ok(format!(
                    "({} if {} is not None else {})",
                    arg_codes[0], arg_codes[0], arg_codes[1]
                )),
                "default" => Ok(format!(
                    "({} if {} is not None else {})",
                    arg_codes[0], arg_codes[0], arg_codes[1]
                )),

                _ => Ok(format!("{}({})", name, arg_codes.join(", "))),
            }
        }

        // Let binding
        Expr::Let { name, value, body } => {
            let value_code = transpile_expr(value, indent, depth)?;
            let body_code = transpile_expr(body, indent, depth)?;
            Ok(format!(
                "(lambda {}: ({}))({})",
                name, body_code, value_code
            ))
        }

        // If expression
        Expr::If {
            condition,
            then_branch,
            else_branch,
        } => {
            let cond_code = transpile_expr(condition, indent, depth)?;
            let then_code = transpile_expr(then_branch, indent, depth)?;
            let else_code = transpile_expr(else_branch, indent, depth)?;
            Ok(format!(
                "({} if _is_truthy({}) else {})",
                then_code, cond_code, else_code
            ))
        }

        // Binary operations
        Expr::Binary { op, left, right } => {
            let left_code = transpile_expr(left, indent, depth)?;
            let right_code = transpile_expr(right, indent, depth)?;

            match op {
                BinaryOp::Add => Ok(format!("({} + {})", left_code, right_code)),
                BinaryOp::Subtract => Ok(format!("({} - {})", left_code, right_code)),
                BinaryOp::Multiply => Ok(format!("({} * {})", left_code, right_code)),
                BinaryOp::Divide => Ok(format!("({} / {})", left_code, right_code)),
                BinaryOp::Modulo => Ok(format!("({} % {})", left_code, right_code)),
                BinaryOp::Equal => Ok(format!("({} == {})", left_code, right_code)),
                BinaryOp::NotEqual => Ok(format!("({} != {})", left_code, right_code)),
                BinaryOp::Less => Ok(format!("({} < {})", left_code, right_code)),
                BinaryOp::Greater => Ok(format!("({} > {})", left_code, right_code)),
                BinaryOp::LessEqual => Ok(format!("({} <= {})", left_code, right_code)),
                BinaryOp::GreaterEqual => Ok(format!("({} >= {})", left_code, right_code)),
                BinaryOp::And => Ok(format!(
                    "(_is_truthy({}) and _is_truthy({}))",
                    left_code, right_code
                )),
                BinaryOp::Or => Ok(format!(
                    "(_is_truthy({}) or _is_truthy({}))",
                    left_code, right_code
                )),
            }
        }

        // Unary operations
        Expr::Unary { op, operand } => {
            let operand_code = transpile_expr(operand, indent, depth)?;
            match op {
                UnaryOp::Not => Ok(format!("(not _is_truthy({}))", operand_code)),
                UnaryOp::Negate => Ok(format!("(-{})", operand_code)),
            }
        }

        // Pipe expression (should be transformed by parser, but handle for completeness)
        Expr::Pipe { .. } => Err(TranspileError::UnsupportedExpression(
            "Pipe expressions should be transformed during parsing".to_string(),
        )),
    }
}

/// Transpile Amoskeag source code to Python
///
/// This is a convenience function that parses and transpiles in one step.
///
/// # Arguments
///
/// * `source` - The Amoskeag source code
/// * `config` - Optional transpiler configuration
///
/// # Returns
///
/// A string containing the generated Python code
pub fn transpile_source(
    source: &str,
    config: Option<TranspileConfig>,
) -> Result<String, Box<dyn std::error::Error>> {
    let config = config.unwrap_or_default();
    let ast = amoskeag_parser::parse(source)?;
    Ok(transpile(&ast, &config)?)
}

#[cfg(test)]
mod tests {
    use super::*;
    use amoskeag_parser::parse;

    #[test]
    fn test_transpile_number() {
        let expr = parse("42").unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains("return 42"));
    }

    #[test]
    fn test_transpile_string() {
        let source = r#""hello""#;
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains("return \"hello\""));
    }

    #[test]
    fn test_transpile_symbol() {
        let source = ":approve";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains("\":approve\""));
    }

    #[test]
    fn test_transpile_variable() {
        let source = "driver.age";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains("_get_nested"));
        assert!(python.contains("\"driver\""));
        assert!(python.contains("\"age\""));
    }

    #[test]
    fn test_transpile_binary_op() {
        let expr = parse("1 + 2").unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains("(1 + 2)"));
    }

    #[test]
    fn test_transpile_function_call() {
        let source = "upcase('hello')";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains(".upper()"));
    }

    #[test]
    fn test_transpile_if_expression() {
        let source = "if age > 18 :adult else :minor end";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains("_is_truthy"));
        assert!(python.contains("\":adult\""));
        assert!(python.contains("\":minor\""));
    }

    #[test]
    fn test_transpile_let_expression() {
        let expr = parse("let x = 5 in x + 1").unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains("lambda x:"));
    }

    #[test]
    fn test_transpile_pipe() {
        let source = "'hello' | upcase";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_imports: false,
            ..Default::default()
        };
        let python = transpile(&expr, &config).unwrap();
        assert!(python.contains(".upper()"));
    }

    #[test]
    fn test_transpile_complex_expression() {
        let source = "
            if driver.age > 16
              :continue
            else
              :deny
            end
        ";
        let expr = parse(source).unwrap();
        let python = transpile(&expr, &Default::default()).unwrap();

        // Check that the Python code contains the expected elements
        assert!(python.contains("def evaluate"));
        assert!(python.contains("_get_nested"));
        assert!(python.contains("_is_truthy"));
        assert!(python.contains("\"driver\""));
        assert!(python.contains("\"age\""));
        assert!(python.contains("\":continue\""));
        assert!(python.contains("\":deny\""));
    }

    #[test]
    fn test_transpile_source() {
        let source = "2 + 3 * 4";
        let python = transpile_source(source, None).unwrap();
        assert!(python.contains("def evaluate"));
        assert!(python.contains("(2 + (3 * 4))"));
    }
}
