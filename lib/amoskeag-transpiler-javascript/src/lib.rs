//! Amoskeag to JavaScript Transpiler
//!
//! This crate provides functionality to transpile Amoskeag programs to JavaScript code.
//! The generated JavaScript code maintains the functional and safe properties of Amoskeag
//! while being executable in Node.js or browser environments.

use amoskeag_parser::{BinaryOp, Expr, UnaryOp};
use std::fmt::Write;
use thiserror::Error;

/// Errors that can occur during transpilation
#[derive(Error, Debug)]
pub enum TranspileError {
    #[error("Failed to format JavaScript code: {0}")]
    FormatError(String),

    #[error("Unsupported expression: {0}")]
    UnsupportedExpression(String),
}

/// Configuration for the transpiler
#[derive(Debug, Clone)]
pub struct TranspileConfig {
    /// Indentation string (default: 2 spaces)
    pub indent: String,
    /// Whether to include runtime helper functions
    pub include_runtime_helpers: bool,
    /// Whether to use ES6 module syntax
    pub use_es6_modules: bool,
    /// Whether to use 'use strict' directive
    pub use_strict: bool,
}

impl Default for TranspileConfig {
    fn default() -> Self {
        Self {
            indent: "  ".to_string(),
            include_runtime_helpers: true,
            use_es6_modules: true,
            use_strict: true,
        }
    }
}

/// Transpile an Amoskeag AST to JavaScript code
///
/// # Arguments
///
/// * `expr` - The AST expression to transpile
/// * `config` - Configuration for the transpiler
///
/// # Returns
///
/// A string containing the generated JavaScript code
pub fn transpile(expr: &Expr, config: &TranspileConfig) -> Result<String, TranspileError> {
    let mut output = String::new();

    // Add header comment
    writeln!(
        &mut output,
        "// Generated by Amoskeag JavaScript Transpiler"
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;

    if config.use_strict {
        writeln!(&mut output, "'use strict';")
            .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    }

    writeln!(&mut output).map_err(|e| TranspileError::FormatError(e.to_string()))?;

    // Generate helper functions if configured
    if config.include_runtime_helpers {
        generate_helpers(&mut output, &config.indent)?;
    }

    // Generate the main function
    writeln!(&mut output, "function evaluate(data) {{")
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        &mut output,
        "{}return {};",
        config.indent,
        transpile_expr(expr, &config.indent, 1)?
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(&mut output, "}}").map_err(|e| TranspileError::FormatError(e.to_string()))?;

    // Export the function if using ES6 modules
    if config.use_es6_modules {
        writeln!(&mut output).map_err(|e| TranspileError::FormatError(e.to_string()))?;
        writeln!(&mut output, "export {{ evaluate }};")
            .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    } else {
        writeln!(&mut output).map_err(|e| TranspileError::FormatError(e.to_string()))?;
        writeln!(&mut output, "module.exports = {{ evaluate }};")
            .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    }

    Ok(output)
}

/// Generate helper functions for the JavaScript runtime
fn generate_helpers(output: &mut String, indent: &str) -> Result<(), TranspileError> {
    // Helper for safe nested object access
    writeln!(output, "function _getNested(obj, ...keys) {{")
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}let current = obj;", indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}for (const key of keys) {{", indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        output,
        "{}{}if (current === null || current === undefined || typeof current !== 'object') {{",
        indent, indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}{}return null;", indent, indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}}}", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}current = current[key];", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}if (current === undefined) {{", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}{}return null;", indent, indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}}}", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}}}", indent).map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}return current;", indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "}}").map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output).map_err(|e| TranspileError::FormatError(e.to_string()))?;

    // Helper for truthiness check (Amoskeag semantics)
    writeln!(output, "function _isTruthy(val) {{")
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(
        output,
        "{}if (val === null || val === undefined) {{",
        indent
    )
    .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}return false;", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}}}", indent).map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}if (typeof val === 'boolean') {{", indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}{}return val;", indent, indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}}}", indent).map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "{}return true;", indent)
        .map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output, "}}").map_err(|e| TranspileError::FormatError(e.to_string()))?;
    writeln!(output).map_err(|e| TranspileError::FormatError(e.to_string()))?;

    Ok(())
}

/// Transpile an expression to JavaScript code
#[allow(clippy::only_used_in_recursion)]
fn transpile_expr(expr: &Expr, indent: &str, depth: usize) -> Result<String, TranspileError> {
    match expr {
        // Literals
        Expr::Number(n) => Ok(format!("{}", n)),
        Expr::String(s) => {
            // Escape special characters for JavaScript strings
            let escaped = s
                .replace('\\', "\\\\")
                .replace('"', "\\\"")
                .replace('\n', "\\n")
                .replace('\r', "\\r")
                .replace('\t', "\\t");
            Ok(format!("\"{}\"", escaped))
        }
        Expr::Boolean(b) => Ok(if *b { "true" } else { "false" }.to_string()),
        Expr::Nil => Ok("null".to_string()),
        Expr::Symbol(s) => Ok(format!("\":{}\"", s)),

        // Array literal
        Expr::Array(elements) => {
            let mut parts = Vec::new();
            for elem in elements {
                parts.push(transpile_expr(elem, indent, depth)?);
            }
            Ok(format!("[{}]", parts.join(", ")))
        }

        // Dictionary literal
        Expr::Dictionary(pairs) => {
            let mut parts = Vec::new();
            for (key, value) in pairs {
                let value_code = transpile_expr(value, indent, depth)?;
                // Use property shorthand if key is a valid identifier
                if is_valid_js_identifier(key) {
                    parts.push(format!("{}: {}", key, value_code));
                } else {
                    parts.push(format!("\"{}\": {}", key, value_code));
                }
            }
            Ok(format!("{{{}}}", parts.join(", ")))
        }

        // Variable access (with dot navigation)
        Expr::Variable(path) => {
            if path.is_empty() {
                return Ok("null".to_string());
            }

            if path.len() == 1 {
                // Simple variable - access from data object
                Ok(format!("data[\"{}\"]", path[0]))
            } else {
                // Nested access using helper
                let keys = path
                    .iter()
                    .map(|k| format!("\"{}\"", k))
                    .collect::<Vec<_>>()
                    .join(", ");
                Ok(format!("_getNested(data, {})", keys))
            }
        }

        // Function call
        Expr::FunctionCall { name, args } => {
            let arg_codes: Result<Vec<_>, _> = args
                .iter()
                .map(|a| transpile_expr(a, indent, depth))
                .collect();
            let arg_codes = arg_codes?;

            // Map Amoskeag functions to JavaScript equivalents
            match name.as_str() {
                // String functions
                "upcase" => Ok(format!("{}.toUpperCase()", arg_codes[0])),
                "downcase" => Ok(format!("{}.toLowerCase()", arg_codes[0])),
                "capitalize" => Ok(format!(
                    "({}.charAt(0).toUpperCase() + {}.slice(1).toLowerCase())",
                    arg_codes[0], arg_codes[0]
                )),
                "strip" => Ok(format!("{}.trim()", arg_codes[0])),
                "split" => Ok(format!("{}.split({})", arg_codes[0], arg_codes[1])),
                "join" => Ok(format!("{}.join({})", arg_codes[0], arg_codes[1])),
                "truncate" => Ok(format!(
                    "{}.substring(0, Math.floor({}))",
                    arg_codes[0], arg_codes[1]
                )),
                "replace" => Ok(format!(
                    "{}.replace({}, {})",
                    arg_codes[0], arg_codes[1], arg_codes[2]
                )),

                // Numeric functions
                "abs" => Ok(format!("Math.abs({})", arg_codes[0])),
                "ceil" => Ok(format!("Math.ceil({})", arg_codes[0])),
                "floor" => Ok(format!("Math.floor({})", arg_codes[0])),
                "round" => {
                    if arg_codes.len() == 2 {
                        Ok(format!(
                            "(({}) => {{
  const factor = Math.pow(10, Math.floor({}));
  return Math.round(({}) * factor) / factor;
}})()",
                            arg_codes[0], arg_codes[1], arg_codes[0]
                        ))
                    } else {
                        Ok(format!("Math.round({})", arg_codes[0]))
                    }
                }
                "plus" => Ok(format!("({} + {})", arg_codes[0], arg_codes[1])),
                "minus" => Ok(format!("({} - {})", arg_codes[0], arg_codes[1])),
                "times" => Ok(format!("({} * {})", arg_codes[0], arg_codes[1])),
                "divided_by" => Ok(format!("({} / {})", arg_codes[0], arg_codes[1])),
                "modulo" => Ok(format!("({} % {})", arg_codes[0], arg_codes[1])),
                "max" => Ok(format!("Math.max({}, {})", arg_codes[0], arg_codes[1])),
                "min" => Ok(format!("Math.min({}, {})", arg_codes[0], arg_codes[1])),

                // Collection functions
                "size" => Ok(format!(
                    "({} !== null && {} !== undefined ? {}.length : 0)",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "first" => Ok(format!(
                    "({} && {}.length > 0 ? {}[0] : null)",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "last" => Ok(format!(
                    "({} && {}.length > 0 ? {}[{}.length - 1] : null)",
                    arg_codes[0], arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "contains" => Ok(format!(
                    "({} !== null && {} !== undefined ? {}.includes({}) : false)",
                    arg_codes[0], arg_codes[0], arg_codes[0], arg_codes[1]
                )),
                "sum" => Ok(format!(
                    "({} !== null && {} !== undefined ? {}.reduce((a, b) => a + b, 0) : 0)",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "avg" => Ok(format!(
                    "({} && {}.length > 0 ? {}.reduce((a, b) => a + b, 0) / {}.length : null)",
                    arg_codes[0], arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "sort" => Ok(format!(
                    "({} !== null && {} !== undefined ? [...{}].sort() : [])",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "keys" => Ok(format!(
                    "({} !== null && {} !== undefined ? Object.keys({}) : [])",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "values" => Ok(format!(
                    "({} !== null && {} !== undefined ? Object.values({}) : [])",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "reverse" => Ok(format!(
                    "({} !== null && {} !== undefined ? [...{}].reverse() : [])",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "at" => Ok(format!(
                    "({} && Math.floor({}) < {}.length ? {}[Math.floor({})] : null)",
                    arg_codes[0], arg_codes[1], arg_codes[0], arg_codes[0], arg_codes[1]
                )),

                // Logic functions
                "choose" => {
                    let index = &arg_codes[0];
                    let array = &arg_codes[1];
                    Ok(format!("({} && Math.floor({}) > 0 && Math.floor({}) <= {}.length ? {}[Math.floor({}) - 1] : null)",
                        array, index, index, array, array, index))
                }
                "if_then_else" => Ok(format!(
                    "(_isTruthy({}) ? {} : {})",
                    arg_codes[0], arg_codes[1], arg_codes[2]
                )),
                "is_number" => Ok(format!("(typeof {} === 'number')", arg_codes[0])),
                "is_string" => Ok(format!("(typeof {} === 'string')", arg_codes[0])),
                "is_boolean" => Ok(format!("(typeof {} === 'boolean')", arg_codes[0])),
                "is_nil" => Ok(format!(
                    "({} === null || {} === undefined)",
                    arg_codes[0], arg_codes[0]
                )),
                "is_array" => Ok(format!("Array.isArray({})", arg_codes[0])),
                "is_dictionary" => Ok(format!(
                    "(typeof {} === 'object' && {} !== null && !Array.isArray({}))",
                    arg_codes[0], arg_codes[0], arg_codes[0]
                )),
                "coalesce" => Ok(format!(
                    "({} !== null && {} !== undefined ? {} : {})",
                    arg_codes[0], arg_codes[0], arg_codes[0], arg_codes[1]
                )),
                "default" => Ok(format!(
                    "({} !== null && {} !== undefined ? {} : {})",
                    arg_codes[0], arg_codes[0], arg_codes[0], arg_codes[1]
                )),

                _ => Ok(format!("{}({})", name, arg_codes.join(", "))),
            }
        }

        // Let binding
        Expr::Let { name, value, body } => {
            let value_code = transpile_expr(value, indent, depth)?;
            let body_code = transpile_expr(body, indent, depth)?;
            Ok(format!("(({}) => ({}))({})", name, body_code, value_code))
        }

        // If expression
        Expr::If {
            condition,
            then_branch,
            else_branch,
        } => {
            let cond_code = transpile_expr(condition, indent, depth)?;
            let then_code = transpile_expr(then_branch, indent, depth)?;
            let else_code = transpile_expr(else_branch, indent, depth)?;
            Ok(format!(
                "(_isTruthy({}) ? {} : {})",
                cond_code, then_code, else_code
            ))
        }

        // Binary operations
        Expr::Binary { op, left, right } => {
            let left_code = transpile_expr(left, indent, depth)?;
            let right_code = transpile_expr(right, indent, depth)?;

            match op {
                BinaryOp::Add => Ok(format!("({} + {})", left_code, right_code)),
                BinaryOp::Subtract => Ok(format!("({} - {})", left_code, right_code)),
                BinaryOp::Multiply => Ok(format!("({} * {})", left_code, right_code)),
                BinaryOp::Divide => Ok(format!("({} / {})", left_code, right_code)),
                BinaryOp::Modulo => Ok(format!("({} % {})", left_code, right_code)),
                BinaryOp::Equal => Ok(format!("({} === {})", left_code, right_code)),
                BinaryOp::NotEqual => Ok(format!("({} !== {})", left_code, right_code)),
                BinaryOp::Less => Ok(format!("({} < {})", left_code, right_code)),
                BinaryOp::Greater => Ok(format!("({} > {})", left_code, right_code)),
                BinaryOp::LessEqual => Ok(format!("({} <= {})", left_code, right_code)),
                BinaryOp::GreaterEqual => Ok(format!("({} >= {})", left_code, right_code)),
                BinaryOp::And => Ok(format!(
                    "(_isTruthy({}) && _isTruthy({}))",
                    left_code, right_code
                )),
                BinaryOp::Or => Ok(format!(
                    "(_isTruthy({}) || _isTruthy({}))",
                    left_code, right_code
                )),
            }
        }

        // Unary operations
        Expr::Unary { op, operand } => {
            let operand_code = transpile_expr(operand, indent, depth)?;
            match op {
                UnaryOp::Not => Ok(format!("(!_isTruthy({}))", operand_code)),
                UnaryOp::Negate => Ok(format!("(-{})", operand_code)),
            }
        }

        // Pipe expression (should be transformed by parser, but handle for completeness)
        Expr::Pipe { .. } => Err(TranspileError::UnsupportedExpression(
            "Pipe expressions should be transformed during parsing".to_string(),
        )),
    }
}

/// Check if a string is a valid JavaScript identifier
fn is_valid_js_identifier(s: &str) -> bool {
    // Check if first character is valid
    let mut chars = s.chars();
    let Some(first) = chars.next() else {
        return false;
    };

    if !first.is_alphabetic() && first != '_' && first != '$' {
        return false;
    }

    // Check remaining characters
    for c in chars {
        if !c.is_alphanumeric() && c != '_' && c != '$' {
            return false;
        }
    }

    true
}

/// Transpile Amoskeag source code to JavaScript
///
/// This is a convenience function that parses and transpiles in one step.
///
/// # Arguments
///
/// * `source` - The Amoskeag source code
/// * `config` - Optional transpiler configuration
///
/// # Returns
///
/// A string containing the generated JavaScript code
pub fn transpile_source(
    source: &str,
    config: Option<TranspileConfig>,
) -> Result<String, Box<dyn std::error::Error>> {
    let config = config.unwrap_or_default();
    let ast = amoskeag_parser::parse(source)?;
    Ok(transpile(&ast, &config)?)
}

#[cfg(test)]
mod tests {
    use super::*;
    use amoskeag_parser::parse;

    #[test]
    fn test_transpile_number() {
        let expr = parse("42").unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("return 42"));
    }

    #[test]
    fn test_transpile_string() {
        let source = r#""hello""#;
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("return \"hello\""));
    }

    #[test]
    fn test_transpile_boolean() {
        let expr = parse("true").unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("return true"));
    }

    #[test]
    fn test_transpile_nil() {
        let expr = parse("nil").unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("return null"));
    }

    #[test]
    fn test_transpile_symbol() {
        let source = ":approve";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("\":approve\""));
    }

    #[test]
    fn test_transpile_variable() {
        let source = "driver.age";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("_getNested"));
        assert!(js.contains("\"driver\""));
        assert!(js.contains("\"age\""));
    }

    #[test]
    fn test_transpile_array() {
        let source = "[1, 2, 3]";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("[1, 2, 3]"));
    }

    #[test]
    fn test_transpile_dictionary() {
        let source = r#"{ name: "Alice", age: 30 }"#;
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("name:"));
        assert!(js.contains("\"Alice\""));
        assert!(js.contains("age:"));
        assert!(js.contains("30"));
    }

    #[test]
    fn test_transpile_binary_op() {
        let expr = parse("1 + 2").unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("(1 + 2)"));
    }

    #[test]
    fn test_transpile_function_call() {
        let source = "upcase('hello')";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains(".toUpperCase()"));
    }

    #[test]
    fn test_transpile_if_expression() {
        let source = "if age > 18 :adult else :minor end";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("_isTruthy"));
        assert!(js.contains("\":adult\""));
        assert!(js.contains("\":minor\""));
    }

    #[test]
    fn test_transpile_let_expression() {
        let expr = parse("let x = 5 in x + 1").unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("((x) =>"));
    }

    #[test]
    fn test_transpile_pipe() {
        let source = "'hello' | upcase";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains(".toUpperCase()"));
    }

    #[test]
    fn test_transpile_complex_expression() {
        let source = "
            if driver.age > 16
              :continue
            else
              :deny
            end
        ";
        let expr = parse(source).unwrap();
        let js = transpile(&expr, &Default::default()).unwrap();

        // Check that the JavaScript code contains the expected elements
        assert!(js.contains("function evaluate"));
        assert!(js.contains("_getNested"));
        assert!(js.contains("_isTruthy"));
        assert!(js.contains("\"driver\""));
        assert!(js.contains("\"age\""));
        assert!(js.contains("\":continue\""));
        assert!(js.contains("\":deny\""));
    }

    #[test]
    fn test_transpile_source() {
        let source = "2 + 3 * 4";
        let js = transpile_source(source, None).unwrap();
        assert!(js.contains("function evaluate"));
        assert!(js.contains("(2 + (3 * 4))"));
    }

    #[test]
    fn test_transpile_equality_operators() {
        let source = "1 == 1";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("==="));
    }

    #[test]
    fn test_transpile_logical_and() {
        let source = "true and false";
        let expr = parse(source).unwrap();
        let config = TranspileConfig {
            include_runtime_helpers: false,
            ..Default::default()
        };
        let js = transpile(&expr, &config).unwrap();
        assert!(js.contains("_isTruthy"));
        assert!(js.contains("&&"));
    }

    #[test]
    fn test_is_valid_js_identifier() {
        assert!(is_valid_js_identifier("name"));
        assert!(is_valid_js_identifier("_private"));
        assert!(is_valid_js_identifier("$jquery"));
        assert!(is_valid_js_identifier("var123"));
        assert!(!is_valid_js_identifier("123var"));
        assert!(!is_valid_js_identifier("my-var"));
        assert!(!is_valid_js_identifier(""));
    }
}
